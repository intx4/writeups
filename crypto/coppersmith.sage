︠37f7755a-5f16-44f7-8fe4-e3b2ee90bd39s︠
"""
Challenge: A bit Weird - UTCTF2021
"""

"""
Provided main.py:
from Crypto.Util import number
from secret import flag
import os

length = 2048
p, q = number.getPrime(length//2), number.getPrime(length//2)
N = p*q
e = 3

m = number.bytes_to_long(flag)
x = number.bytes_to_long(os.urandom(length//8))

c = pow(m|x, e, N)
print('N =', N);
print('e =', e);
print('c =', c);
print('m&x =', m&x);
"""


# Provided msg.txt:

N = 13876129555781460073002089038351520612247655754841714940325194761154811715694900213267064079029042442997358889794972854389557630367771777876508793474170741947269348292776484727853353467216624504502363412563718921205109890927597601496686803975210884730367005708579251258930365320553408690272909557812147058458101934416094961654819292033675534518433169541534918719715858981571188058387655828559632455020249603990658414972550914448303438265789951615868454921813881331283621117678174520240951067354671343645161030847894042795249824975975123293970250188757622530156083354425897120362794296499989540418235408089516991225649
e = 3
c = 6581985633799906892057438125576915919729685289065773835188688336898671475090397283236146369846971577536055404744552000913009436345090659234890289251210725630126240983696894267667325908895755610921151796076651419491871249815427670907081328324660532079703528042745484899868019846050803531065674821086527587813490634542863407667629281865859168224431930971680966013847327545587494254199639534463557869211251870726331441006052480498353072578366929904335644501242811360758566122007864009155945266316460389696089058959764212987491632905588143831831973272715981653196928234595155023233235134284082645872266135170511490429493
m_and_x = 947571396785487533546146461810836349016633316292485079213681708490477178328756478620234135446017364353903883460574081324427546739724

x = 15581107453382746363421172426030468550126181195076252322042322859748260918197659408344673747013982937921433767135271108413165955808652424700637809308565928462367274272294975755415573706749109706624868830430686443947948537923430882747239965780990192617072654390726447304728671150888061906213977961981340995242772304458476566590730032592047868074968609272272687908019911741096824092090512588043445300077973100189180460193467125092550001098696240395535375456357081981657552860000358049631730893603020057137233513015505547751597823505590900290756694837641762534009330797696018713622218806608741753325137365900124739257740

"""
Typical RSA setting with modulus of 2048 bits. Only weird operation outside protocol: the message m is 'ORed' with a random value x.
We know x and also m_and_x.
From this we could infer some bits of message m( m_and_x has 1 where both x and m have 1 -> we know that m = m_and_x where x has bits set to 1). This is however not that useful for the sake of the exploit.
One thing to notice is that m|x just sets some bits of x to 1 where m has bits to 1 -> is the same thing as doing x + y.
Also y is bounded by the size of m (which should be 'small enough' : m < N ** 1/3. A wild guess of this can be noticing that m_and_x ** 3 < N).
We can use the Coppersmith Method -> retrieve 'small' (< N ** 1/d-eps where d is the degree of f) roots of f efficiently)
"""

P.<w> = PolynomialRing(Zmod(N), implementation = 'NTL') #NTL for using smallroots
f = (x + w)**e - c #this has a root a value w s.t when summed to x it returns m|x
y = f.small_roots(X = int(pow(N, 1/4)))[0] #bound on the root
print(y)
m_or_x = x + y
#use m + x = m_or_x + m_and_x
m = m_or_x + m_and_x - x
print("FLAG: ", int(m).to_bytes(length = 400, byteorder = 'big').decode())
